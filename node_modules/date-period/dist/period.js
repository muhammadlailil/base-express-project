"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _dateDuration = _interopRequireDefault(require("date-duration"));

var _debug = _interopRequireDefault(require("debug"));

var debug = (0, _debug.default)('date-period');

var filterDate = function filterDate(date) {
  if (typeof date.toDate === 'function') {
    date = date.toDate();
  }

  if (Object.prototype.toString.call(date) !== '[object Date]') {
    throw new Error('Invalid date');
  }

  return new Date(+date);
};

var addDuration = function addDuration(date, duration) {
  var result = duration.addTo(date);

  if (+date === +result) {
    throw new Error("Invalid period (invalid duration '".concat(duration, "')"));
  }

  return result;
};
/**
 * constructor
 * @param  {Date} options.start Start date
 * @param  {Object|string} options.duration Duration
 * @param  {Date} options.end End date
 * @param  {number} options.recurrence Recurrences
 * @param  {string} options.iso Duration in ISO 8601 format
 * @return {Object} Period
 */


function createPeriod(_ref) {
  var _period;

  var start = _ref.start,
      duration = _ref.duration,
      end = _ref.end,
      recurrence = _ref.recurrence,
      iso = _ref.iso;

  if (iso) {
    if (typeof iso !== 'string' || iso[0] !== 'R') {
      throw new Error('Invalid period (invalid ISO format)');
    }

    var _iso$split = iso.split(/\//);

    var _iso$split2 = (0, _slicedToArray2.default)(_iso$split, 3);

    recurrence = _iso$split2[0];
    start = _iso$split2[1];
    duration = _iso$split2[2];
    start = new Date(start);
    recurrence = parseInt(recurrence.substr(1), 10);
  }

  start = filterDate(start);

  if ((0, _typeof2.default)(duration) === 'object' && typeof duration.toString === 'function') {
    duration = duration.toString();
  }

  duration = (0, _dateDuration.default)(duration);

  if (end) {
    end = filterDate(end);
  } else if (typeof recurrence !== 'undefined') {
    if (typeof recurrence !== 'number') {
      throw new Error('Invalid period (invalid number of recurrences)');
    }
  } else {
    throw new Error('Invalid period (missing end or number of recurrences)');
  }

  if (end && start >= end) {
    throw new Error('Invalid period (end needs to be after start)');
  }

  var period = (_period = {}, (0, _defineProperty2.default)(_period, Symbol.iterator,
  /*#__PURE__*/
  _regenerator.default.mark(function _callee() {
    var date, i;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            date = new Date(+start);

            if (!end) {
              _context.next = 11;
              break;
            }

          case 2:
            if (!(date < end)) {
              _context.next = 9;
              break;
            }

            debug("hit ".concat(date));
            _context.next = 6;
            return date;

          case 6:
            date = addDuration(date, duration);
            _context.next = 2;
            break;

          case 9:
            _context.next = 23;
            break;

          case 11:
            debug("hit ".concat(date));
            _context.next = 14;
            return date;

          case 14:
            i = 0;

          case 15:
            if (!(i < recurrence)) {
              _context.next = 23;
              break;
            }

            date = addDuration(date, duration);
            debug("hit ".concat(date));
            _context.next = 20;
            return date;

          case 20:
            i++;
            _context.next = 15;
            break;

          case 23:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })), (0, _defineProperty2.default)(_period, "toArray", function toArray() {
    return Array.from(period);
  }), (0, _defineProperty2.default)(_period, "toString", function toString() {
    return "R".concat(period.toArray().length - 1, "/").concat(start.toISOString(), "/").concat(duration);
  }), _period);
  return Object.freeze(period);
}

var _default = createPeriod;
exports.default = _default;
//# sourceMappingURL=period.js.map