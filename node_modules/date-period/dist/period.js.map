{"version":3,"sources":["../src/period.js"],"names":["debug","filterDate","date","toDate","Object","prototype","toString","call","Error","Date","addDuration","duration","result","addTo","createPeriod","start","end","recurrence","iso","split","parseInt","substr","period","Symbol","iterator","i","Array","from","toArray","length","toISOString","freeze"],"mappings":"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","sourcesContent":["import createDuration from 'date-duration';\nimport createDebug from 'debug';\n\nconst debug = createDebug('date-period');\n\nconst filterDate = date => {\n  if (typeof date.toDate === 'function') {\n    date = date.toDate();\n  }\n\n  if (Object.prototype.toString.call(date) !== '[object Date]') {\n    throw new Error('Invalid date');\n  }\n\n  return new Date(+date);\n};\n\nconst addDuration = (date, duration) => {\n  const result = duration.addTo(date);\n\n  if (+date === +result) {\n    throw new Error(`Invalid period (invalid duration '${duration}')`);\n  }\n\n  return result;\n};\n\n/**\n * constructor\n * @param  {Date} options.start Start date\n * @param  {Object|string} options.duration Duration\n * @param  {Date} options.end End date\n * @param  {number} options.recurrence Recurrences\n * @param  {string} options.iso Duration in ISO 8601 format\n * @return {Object} Period\n */\nfunction createPeriod ({ start, duration, end, recurrence, iso }) {\n  if (iso) {\n    if (typeof iso !== 'string' || iso[0] !== 'R') {\n      throw new Error('Invalid period (invalid ISO format)');\n    }\n\n    [recurrence, start, duration] = iso.split(/\\//);\n\n    start = new Date(start);\n    recurrence = parseInt(recurrence.substr(1), 10);\n  }\n\n  start = filterDate(start);\n\n  if (typeof duration === 'object' && typeof duration.toString === 'function') {\n    duration = duration.toString();\n  }\n\n  duration = createDuration(duration);\n\n  if (end) {\n    end = filterDate(end);\n  } else if (typeof recurrence !== 'undefined') {\n    if (typeof recurrence !== 'number') {\n      throw new Error('Invalid period (invalid number of recurrences)');\n    }\n  } else {\n    throw new Error('Invalid period (missing end or number of recurrences)');\n  }\n\n  if (end && start >= end) {\n    throw new Error('Invalid period (end needs to be after start)');\n  }\n\n  const period = {\n    * [Symbol.iterator] () {\n      let date = new Date(+start);\n\n      if (end) {\n        while (date < end) {\n          debug(`hit ${date}`);\n          yield date;\n\n          date = addDuration(date, duration);\n        }\n      } else {\n        debug(`hit ${date}`);\n        yield date;\n\n        for (let i = 0; i < recurrence; i++) {\n          date = addDuration(date, duration);\n\n          debug(`hit ${date}`);\n          yield date;\n        }\n      }\n    },\n    toArray: () => Array.from(period),\n    toString: () => `R${period.toArray().length - 1}/${start.toISOString()}/${duration}`\n  };\n\n  return Object.freeze(period);\n}\n\nexport default createPeriod;\n"],"file":"period.js"}