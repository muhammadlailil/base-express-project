"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createDuration;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _debug = _interopRequireDefault(require("debug"));

var debug = (0, _debug.default)('date-duration');

var clone = function clone(value) {
  if ((0, _typeof2.default)(value) === 'object' && typeof value.toDate === 'function') {
    return value.toDate();
  }

  return new Date(+value);
};

var dateParser = /P(\d+Y)?(\d+M)?(\d+W)?(\d+D)?/;
var timeParser = /T(\d+H)?(\d+M)?(\d+S)?/;
var methods = {
  Y: 'FullYear',
  M: 'Month',
  W: 'Date',
  D: 'Date',
  T: {
    H: 'UTCHours',
    M: 'UTCMinutes',
    S: 'UTCSeconds'
  }
};

var parseIso = function parseIso(parser, iso) {
  return (iso.match(parser) || [undefined]).slice(1).filter(function (part) {
    return /^[0-9]+[A-Z]$/i.test(part);
  }).map(function (part) {
    return (0, _defineProperty2.default)({}, part[part.length - 1], parseInt(part.slice(0, -1), 10));
  });
};

var applyParts = function applyParts(date, parts, methods, operator) {
  Object.keys(parts).forEach(function (key) {
    if (key === 'T') {
      date = applyParts(date, parts.T, methods.T, operator);
    } else {
      var original = date["get".concat(methods[key])]();
      var value = operator(original, key !== 'W' ? parts[key] : parts[key] * 7);
      date["set".concat(methods[key])](value);
      debug("set ".concat(key, " ").concat(original, " to ").concat(value, ": ").concat(date));
    }
  });
  return date;
};

var joinParts = function joinParts(parts, range) {
  return Object.keys(parts || {}).filter(function (key) {
    return range.indexOf(key) >= 0;
  }).map(function (key) {
    return "".concat(parts[key]).concat(key);
  }).join('');
};

var mergeParts = function mergeParts(left, right, operator) {
  return (0, _toConsumableArray2.default)(new Set(Object.keys(left).concat(Object.keys(right)))).reduce(function (result, key) {
    if (key === 'T') {
      result[key] = mergeParts(left[key], right[key], operator);
    } else {
      result[key] = Math.abs(operator(left[key] || 0, right[key] || 0));
    }

    return result;
  }, {});
};

var updateParts = function updateParts(parts, operator) {
  return Object.keys(parts).reduce(function (result, key) {
    if (key === 'T') {
      result[key] = updateParts(parts[key], operator);
    } else {
      result[key] = operator(parts[key]);
    }

    return result;
  }, {});
};
/**
 * @constructor
 * @param  {string|object} iso Duration as a string (ISO 8601 notation) or object
 * @return {object} Duration
 */


function createDuration(iso) {
  if (!iso) {
    throw new Error('Invalid duration: no input');
  }

  var parts = {};

  if (typeof iso === 'string') {
    parts = Object.assign.apply(Object, [{}].concat((0, _toConsumableArray2.default)(parseIso(dateParser, iso))));
    var timeParts = parseIso(timeParser, iso);

    if (timeParts.length > 0) {
      Object.assign(parts, {
        T: Object.assign.apply(Object, [{}].concat((0, _toConsumableArray2.default)(timeParts)))
      });
    }

    if (Object.keys(parts) <= 0) {
      throw new Error("Invalid duration: invalid ISO format (".concat(iso, ")"));
    }
  } else if ('P' in iso) {
    parts = Object.assign({}, iso.P);
  } else {
    throw new Error("Invalid duration: invalid input (".concat(iso, ")"));
  }

  return Object.freeze(Object.assign({
    P: parts
  }, {
    /**
     * Convert to a string in ISO 8601 notation
     * @return {string}
     */
    toString: function toString() {
      return "P".concat(joinParts(parts, ['Y', 'M', 'W', 'D'])).concat(parts.T ? "T".concat(joinParts(parts.T, ['H', 'M', 'S'])) : '');
    },

    /**
     * Add duration to a date
     * @param  {Date} date
     * @return {Date}
     */
    addTo: function addTo(date) {
      return applyParts(clone(date), parts, methods, function (left, right) {
        return left + right;
      });
    },

    /**
     * Subtract duration from a date
     * @param  {Date} date
     * @return {Date}
     */
    subtractFrom: function subtractFrom(date) {
      return applyParts(clone(date), parts, methods, function (left, right) {
        return left - right;
      });
    },

    /**
     * Add (merge) two durations
     * @param  {Duration} duration
     * @return {Duration}
     */
    add: function add(duration) {
      return createDuration({
        P: mergeParts(parts, duration.P, function (left, right) {
          return left + right;
        })
      });
    },

    /**
     * Multiply parts of the duration by a number
     * @param  {number} multiplier
     * @return {Duration}
     */
    multiply: function multiply(multiplier) {
      return createDuration({
        P: updateParts(parts, function (value) {
          return value * multiplier;
        })
      });
    }
  }));
}
//# sourceMappingURL=duration.js.map